# Chapter 02. 변수와 자료형

교육 과정에서 제공되는 강의 자료(동영상)을 보면서 부족한 내용은 **남궁성님의 Java의 정석 3판**을 추가적으로 읽으며 학습하였습니다.

---

## 컴퓨터에서 자료 표현하기

- 한 자리의 2진수 = `bit`(**bi**nary digi**t**) : 컴퓨터에서 자료를 표현하는 최소 단위 0 또는 1
- 8bit = 1byte (데이터의 기본 단위)
- 32bit = 4byte = 1word (CPU가 한 번에 처리할 수 있는 데이터의 크기, 64bit 컴퓨터에선 8바이트임)
- n비트로 표현할 수 있는 10진수
  - 값의 개수 : $2^n$
  - 값의 범위 : 0 ~ $2^n$-1
- 음수를 표현하는 방법 : 2의보수 = 0과 1 반전(1의 보수) + 1
- 음수를 2진수로 표현하는 방법 : 음수 → 1) 절대값을 2진수로 변환 → 2) 0과 1 반전(1의 보수) + 1

## 변수(variable)

- 단 하나의 값을 저장할 수 있는 메모리상(RAM)의 공간.
- 변수를 선언하면, 메모리의 빈 공간에 `변수타입`에 알맞은 크기의 저장공간(메모리)이 확보되고, `변수이름`을 통해 메모리의 위치를 참조한다.
- 메모리는 여러 프로그램이 공유하는 자원이므로 전에 다른 프로그램에 의해 알수없는 값(garbage value)이 남아있을 수 있기 때문에, 변수를 사용하기 전에 반드시 변수를 `초기화(initialization)` 해야 한다.
- 지역변수는 사용되기 전에 초기화를 반드시 해야 하지만 클래스변수와 인스턴스변수는 초기화를 생략할 수 있다.
- 명명규칙(naming convention)
  1. 대소문자가 구분되며 길이에 제한이 없다.
  2. 예약어(=keyword, reserved word)를 사용해서는 안 된다.
  3. 숫자로 시작해서는 안 된다.
  4. 특수문자는 `_` 와 `$` 만을 허용한다.
- +) java coding convention
  1. 클래스의 이름의 첫 글자는 항상 대문자로 한다.
  2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다. (camelCase)
  3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 '\_'로 구분한다. (SNAKE_CASE)

## 변수의 타입(data type)

모든 변수에는 타입이 있으며, 변수의 타입에 따라 저장할 수 있는 값의 종류와 범위가 달라진다. 변수를 선언할 때 저장하고자 하는 값을 고려하여 가장 알맞은 타입을 선택하면 된다.

- 기본형 (Primitive type) : 실제 값을 저장

  boolean, char, byte, short, int, long, float, double

  - 논리형 - boolean(1byte)
    - 자바에서는 대소문자가 구별되기 때문에 `TRUE` 와 `true` 는 다른 것으로 간주된다는 것 주의
  - 문자형 - char(2byte)
    - \u0000 ~ \uffff (0 ~ 65535)
    - 문자마다 일련번호를 부여한 것이라 부호비트가 필요하지 않아 표현 범위가 `short`와 다름
    - 인코딩(encoding) : 문자를 코드로 변환하는 것. 문자를 저장할 때는 인코딩을 해서 숫자로 변환해서 저장.
    - 디코딩(decoding) : 코드를 문자로 변환하는 것. 저장된 문자를 읽어올 때는 디코딩을 해서 숫자를 원래의 문자로 되돌림.
    - 문자세트(char-set) : 문자를 위한 코드 값(숫자 값)들을 정해 놓은 세트
      - 아스키(ASCII) : American Standard Code for Information Interchange. 1바이트로 영문자, 숫자, 특수문자 등을 표현
      - 유니코드(Unicode) : 한글과 같은 복잡한 언어를 표현하기 위한 표준 인코딩. `UTF-8`, `UTF-16` 이 대표적
    - 어떤 문자의 유니코드를 알고싶으면, char → int 로 형변환(casting)
  - 정수형 - byte(1byte), short(2byte), **int**(4byte), long(8byte)

    - byte : -128 ~ 127
    - short : -32,768 ~ 32,767
    - int : -2,147,483,648 ~ 2,147,483,647 (약 20억)
    - long : -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (약 800경)

    - n비트로 표현할 수 있는 값의 개수 = $2^n$개  
      n비트로 표현할 수 있는 부호 없는 정수의 범위 = 0~($2^n$)-1  
      n비트로 표현할 수 있는 부호 있는 정수의 범위 = -2^(n-1) ~ 2^(n-1)-1

    - 정수형 변수를 선언할 때는 `int` 타입으로 하고, `int` 의 범위(약 +-20억)를 넘어서는 수를 다뤄야 할 때는 `long` 을 사용한다. `byte` 나 `short` 은 성능보다 저장공간을 절약하는 것이 더 중요할 때 사용한다.
    - 오버플로우(overflow) : 타입이 표현할 수 있는 값의 범위를 넘어서는 것
      - 최대값 + 1 → 최소값
      - 최소값 - 1 → 최대값

  - 실수형 - float(4byte), **double**(8byte)
    - float : 정밀도(precision) 7자리
    - double : 정밀도(precision) 15자리
    - 연산속도의 향상이나 메모리를 절약하려면 `float` 를 선태하고, 더 큰 값의 범위나 정밀도를 필요로 한다면 `double` 을 선택한다.
    - 실수는 `부동 소수점 방식(부호(Sign bit) + 지수(Exponent) + 가수(Mantissa))`으로 저장(표현)한다. 지수와 가수로 표현 되는 부동 소수 점은 0을 표현할 수 없으므로 부동 소수점 방식에는 약간의 오차가 발생할 수 있다.
    - 오버플로우(overflow) : 표현범위의 최대값을 벗어나면 값은 `무한대(infinity)` 가 된다.
    - 언더플로우(underflow) : 표현범위의 최소값보다 작은 값이 되면 값은 `0` 이 된다.
  - +) Java10부터는 지역변수에 한해서 자료형 없이 변수에 대입되는 값을 보고 컴파일러가 타입을 추론하여 변수를 사용하는, 지역 변수 자료형 추론(local variable type inference) 기능이 추가되었다.

- 참조형 (Reference type)
  - 8개의 기본형을 제외한 나머지(String, System 등) 타입. 객체의 주소(메모리 주소)를 저장한다.
  - JDK에서 제공되는 클래스와 프로그래머가 정의하는 클래스
  - C언어와 달리 참조형 변수 간의 연산을 할 수 없다.
  - 참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 변수의 타입이 된다. (→ 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 것)

## 상수와 리터럴(constant & literal)

- 변수(variable) : 하나의 값을 저장하기 위한 공간
- 상수(constant) : 값을 한 번만 저장 가능한 변하지 않는 수 (선언문 앞에 `final` 키워드 붙여서 선언). 리터럴에 *의미있는 이름*을 붙여서 코드의 이해와 수정을 쉽게 만든다.
- 리터럴(literal) : 그 자체로 값을 의미하는 것(ex. 10, 3.14, 'A', true). 모든 리터럴은 상수 풀(constant pool)에 저장되어 있음. 상수 풀에 저장될 때 정수는 int, 실수는 double로 저장된다.

  - 접미사 : `L` : long, `f` : float
  - 접두사 : `0b` : 2진수, `0` : 8진수, `0x` : 16진수

- 변수와 리터럴의 타입 불일치
  1. 범위가 변수 > 리터럴 인 경우, OK
  2. 범위가 변수 < 리터럴 인 경우, Error

## 형변환(casting)

변수나 상수의 타입을 다른 타입으로 변환하는 것.

- 묵시적 형변환(implicit type conversion) : 값의 범위가 작은 타입에서 큰 타입으로, 덜 정밀한 타입에서 더 정밀한 타입으로 대입되는 경우

  ```java
  float f = 1234; // float f = (float)1234; 와 같음.
  ```

  byte → short, char → int → long → float → double

  화살표방향으로의 변환은 자동 형변환이 되며, 반대 방향으로의 반환은 반드시 형변환 연산자를 싸줘야 한다.

- 명시적 형변환(explicit type conversion) : 변환 되는 자료 형을 명시하며, 자료의 손실이 발생할 수 있다.

  ```java
  // (타입)피연산자
  // () : 캐스트 연산자, 형변환 연산자
  double d = 85.4;
  int score = (int)d; // double 타입의 변수 d를 int 타입으로 형변환

  System.out.println(score); // 85
  System.out.println(d); // 85.4
  ```

- 문자와 숫자간의 변환
  - 숫자 + '0' = 문자
  - 문자 - '0' = 숫자
- 문자열로의 변환
  - 숫자 + "" = 문자열
- 문자열을 숫자로 변환
  - Integer.parseInt("3")
  - Double.parseDouble("3.4")
  - "3".ChatAt(0)

## printf()

`println()` : 사용하기엔 편하지만, 변수의 값을 그대로 출력하므로 값을 변환하지 않고는 다른 형식으로 출력할 수 없음 ⇒ `printf()` 사용!

- `printf()` 의 지시자(specifier) - 변수의 값을 여러 가지 형식으로 변환하여 출력할 수 있음.

  - `%b` : **b**oolean

  - `%d` : 10진(**d**ecimal) 정수

  - `%o` : 8진(**o**ctal) 정수

  - `%x, %X` : 16진(he**x**a-decimal) 정수

  - `%f` : 부동 소수점(**f**loating-point) - 기본적으로 소수점 아래 6자리까지만 출력(7자리에서 반올림), 전체 자리수와 소수점 아래의 자리수를 지정할 수도 있다.

  - `%e, %E` : 지수(**e**xponent) 표현식

  - `%g` : 실수 값을 간략하게 표현

  - `%c` : 문자(**c**haracter)

  - `%s` : 문자열(**s**tring)

  - `%n` : 줄바꿈(`\n` 을 사용해도 되지만, OS마다 줄바꿈 문자가 다를 수 있기 때문에 `%n` 을 사용하는 것이 안전!)

  지시자 앞에 #을 붙이면(ex: `%#o` ) 접두사를 나타낼 수 있다.

  ```java
  System.out.printf("[%5d]%n" , 10); // [   10]
  System.out.printf("[%-5d]%n", 10); // [10   ] 왼쪽정렬
  System.out.printf("[%05d]%n", 10); // [00010] 공백을 0으로 채움

  // %전체자리.소수점아래자리f
  System.out.printf("d=%14.10f%n", d); // 전체 14자리 중 소수점 아래 10자리
  ```

## Scanner

```java
import java.util.*; // Scanner 클래스를 사용하기 위해 추가

Scanner scanner = new Scanner(System.in); // Scanner 클래스의 객체를 생성

String input = scanner.nextLine(); // 입력받은 내용을 input에 저장
int num = scanner.nextInt(); // 입력받은 정수를 num에 저장

// nextInt()같은 메서드들은 화면에서 연속적으로 값을 입력받아서 사용하기 까다로우므로,
int num = Integer.parseInt(input) // nextLine()으로 입력받은 값을 적절히 변환하는 것이 낫다.
```

---

## Reference

남궁성, 『Java의 정석 3판』, 도우출판(2016), p20-83(Chapter 02 - 변수 variable).
